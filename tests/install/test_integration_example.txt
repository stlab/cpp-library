# Integration Example: Using Dependency Provider with cpp-library
# This demonstrates the recommended workflow for CMake 3.24+

## Example CMakeLists.txt with Dependency Tracking

```cmake
cmake_minimum_required(VERSION 3.24)

# Step 1: Setup CPM before project()
include(cmake/CPM.cmake)

# Step 2: Fetch cpp-library before project()
CPMAddPackage("gh:stlab/cpp-library@X.Y.Z")
include(${cpp-library_SOURCE_DIR}/cpp-library.cmake)

# Step 3: Enable dependency tracking BEFORE project()
cpp_library_enable_dependency_tracking()

# Step 4: Call project() - this installs the dependency provider
project(my-library VERSION 1.0.0)

# Step 5: Add dependencies - all tracked automatically
CPMAddPackage("gh:stlab/stlab-enum-ops@1.0.0")
CPMAddPackage("gh:stlab/stlab-copy-on-write@2.1.0")
find_package(Boost 1.79 COMPONENTS filesystem system)

# Step 6: Setup your library
cpp_library_setup(
    DESCRIPTION "My example library"
    NAMESPACE mylib
    HEADERS mylib.hpp
)

# Step 7: Link dependencies
target_link_libraries(my-library INTERFACE
    stlab::enum-ops          # Tracked: version 1.0.0
    stlab::copy-on-write     # Tracked: version 2.1.0
    Boost::filesystem        # Tracked: COMPONENTS filesystem
    Boost::system            # Tracked: COMPONENTS system (will be merged)
    Threads::Threads         # System package (auto-detected)
)
```

## Generated Config File

When you install this library, cpp-library generates `my-libraryConfig.cmake`:

```cmake
include(CMakeFindDependencyMacro)

# Dependencies captured from your build configuration
find_dependency(stlab-enum-ops 1.0.0)
find_dependency(stlab-copy-on-write 2.1.0)
find_dependency(Boost 1.79 COMPONENTS filesystem system)  # Components merged
find_dependency(Threads)

include("${CMAKE_CURRENT_LIST_DIR}/my-libraryTargets.cmake")
```

## Key Benefits

1. **Exact Syntax Capture**: The find_dependency() calls match your original find_package() calls
2. **Automatic Version Tracking**: No need to manually specify versions
3. **Component Merging**: Multiple components of the same package are intelligently merged
4. **Conditional Dependencies**: Only dependencies actually linked are included
5. **System Package Detection**: Common packages like Threads don't require versions

## CMake Version Requirement

cpp-library requires CMake 3.24+ for dependency provider support. This is a hard requirement.

If you need to use CMake 3.20-3.23, use an older version of cpp-library that supports the introspection method.

## Handling Special Cases

### QUIET Dependencies (Conditional/Optional Packages)

When you use `find_package()` with the QUIET flag, cpp-library automatically filters out dependencies that weren't found. This prevents phantom dependencies in your Config file:

```cmake
# This will only be included in the Config if Qt5 is actually found
find_package(Qt5 QUIET COMPONENTS Core)

if(Qt5_FOUND)
    target_link_libraries(my-library INTERFACE Qt5::Core)
endif()
```

**Best Practice for Conditional Dependencies:**

```cmake
# Option 1: Use if() to conditionally search (recommended)
if(MYLIB_FEATURE_X)
    find_package(Qt5 COMPONENTS Core)  # Only searched if feature enabled
    target_link_libraries(my-library INTERFACE Qt5::Core)
endif()

# Option 2: Use QUIET and check _FOUND (automatic filtering)
find_package(Qt5 QUIET COMPONENTS Core)
if(Qt5_FOUND)
    target_link_libraries(my-library INTERFACE Qt5::Core)
endif()
```

Both approaches work correctly with cpp-library's dependency tracking.

### Non-namespaced Targets

Non-namespaced targets require explicit mapping (both with and without provider):

```cmake
cpp_library_map_dependency("opencv_core" "OpenCV 4.5.0")
cpp_library_map_dependency("opencv_imgproc" "OpenCV 4.5.0")

target_link_libraries(my-library INTERFACE opencv_core opencv_imgproc)
```

### Manual Overrides (Rare)

Custom mappings can override tracked dependencies if needed:

```cmake
# If you need to override what the provider tracked:
cpp_library_map_dependency("SomePackage::Component" "SomePackage 2.0.0 CONFIG")
```

This is rarely needed since the provider captures the original syntax accurately.

## Testing Your Installation

After installing your library, test that dependencies resolve correctly:

```bash
# Install your library
cmake --preset=default
cmake --build --preset=default
cmake --install build/default --prefix /path/to/install

# Test in a consumer project
cd /tmp/test-consumer
cat > CMakeLists.txt << 'EOF'
cmake_minimum_required(VERSION 3.20)
project(test-consumer)

include(cmake/CPM.cmake)
set(CMAKE_PREFIX_PATH "/path/to/install")
set(CPM_USE_LOCAL_PACKAGES ON)

find_package(my-library REQUIRED)
add_executable(test main.cpp)
target_link_libraries(test PRIVATE mylib::my-library)
EOF

cmake -B build
cmake --build build
```

If all dependencies are correctly specified, the consumer project will build successfully.

